/*
White Label Communications CPaas API Documentation

A CPaaS platform API

API version: 1.1
Contact: support@whitelabelcomm.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// VoicemailAPIService VoicemailAPI service
type VoicemailAPIService service

type ApiV1AccountAccountIDVoicemailGetRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	startKey *string
	pageSize *int32
}

// start_key for pagination that was returned as next_start_key from your previous call
func (r ApiV1AccountAccountIDVoicemailGetRequest) StartKey(startKey string) ApiV1AccountAccountIDVoicemailGetRequest {
	r.startKey = &startKey
	return r
}

// number of records to return, range 1 to 50
func (r ApiV1AccountAccountIDVoicemailGetRequest) PageSize(pageSize int32) ApiV1AccountAccountIDVoicemailGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiV1AccountAccountIDVoicemailGetRequest) Execute() (*ServiceDocsVoicemailGetAll, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailGetExecute(r)
}

/*
V1AccountAccountIDVoicemailGet Get Voicemail Box List

List all voicemail boxes in an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alpha numeric
 @return ApiV1AccountAccountIDVoicemailGetRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailGet(ctx context.Context, accountID string) ApiV1AccountAccountIDVoicemailGetRequest {
	return ApiV1AccountAccountIDVoicemailGetRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailGetAll
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailGetExecute(r ApiV1AccountAccountIDVoicemailGetRequest) (*ServiceDocsVoicemailGetAll, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailGetAll
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailPostRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemail *ServiceVOIPVoicemailAddEditData
}

// voicemail payload fields
func (r ApiV1AccountAccountIDVoicemailPostRequest) Voicemail(voicemail ServiceVOIPVoicemailAddEditData) ApiV1AccountAccountIDVoicemailPostRequest {
	r.voicemail = &voicemail
	return r
}

func (r ApiV1AccountAccountIDVoicemailPostRequest) Execute() (*ServiceDocsVoicemailGetSingle, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailPostExecute(r)
}

/*
V1AccountAccountIDVoicemailPost Create Voicemail Box

Create a voicemail box for receiving and storing voicemail messages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID account ID, 32 alphanumeric
 @return ApiV1AccountAccountIDVoicemailPostRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailPost(ctx context.Context, accountID string) ApiV1AccountAccountIDVoicemailPostRequest {
	return ApiV1AccountAccountIDVoicemailPostRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailGetSingle
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailPostExecute(r ApiV1AccountAccountIDVoicemailPostRequest) (*ServiceDocsVoicemailGetSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailGetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.voicemail == nil {
		return localVarReturnValue, nil, reportError("voicemail is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.voicemail
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDDeleteRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDDeleteRequest) Execute() (*ServiceDocsVoicemailGetSingle, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDDeleteExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDDelete Delete Voicemail Box

Delete a voicemail box in an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alpha numeric
 @param voicemailID Voicemail ID, 32 alpha numeric
 @return ApiV1AccountAccountIDVoicemailVoicemailIDDeleteRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDDelete(ctx context.Context, accountID string, voicemailID string) ApiV1AccountAccountIDVoicemailVoicemailIDDeleteRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDDeleteRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailGetSingle
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDDeleteExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDDeleteRequest) (*ServiceDocsVoicemailGetSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailGetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDGetRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDGetRequest) Execute() (*ServiceDocsVoicemailGetSingle, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDGetExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDGet Get Voicemail Box Details

Get information about a single voicemail box.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alpha numeric
 @param voicemailID Voicemail ID, 32 alpha numeric
 @return ApiV1AccountAccountIDVoicemailVoicemailIDGetRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDGet(ctx context.Context, accountID string, voicemailID string) ApiV1AccountAccountIDVoicemailVoicemailIDGetRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDGetRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailGetSingle
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDGetExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDGetRequest) (*ServiceDocsVoicemailGetSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailGetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
	startKey *string
	pageSize *int32
}

// start_key for pagination that was returned as next_start_key from your previous call
func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest) StartKey(startKey string) ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest {
	r.startKey = &startKey
	return r
}

// number of records to return, range 1 to 50
func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest) PageSize(pageSize int32) ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest) Execute() (*ServiceDocsVoicemailMessageGetAll, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDMessageGetExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDMessageGet Get Voicemail Message List

Get a list of voicemail messages from an account's voicemail box.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alpha numeric
 @param voicemailID voicemail ID, 32 alpha numeric
 @return ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageGet(ctx context.Context, accountID string, voicemailID string) ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailMessageGetAll
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageGetExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDMessageGetRequest) (*ServiceDocsVoicemailMessageGetAll, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailMessageGetAll
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDMessageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}/message"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDeleteRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
	messageID string
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDeleteRequest) Execute() (*ServiceDocsVoicemailMessageGetSingle, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDeleteExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDelete Delete Voicemail Message

Delete a voicemail message from a voicemail box in an account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alpha numeric
 @param voicemailID Voicemail ID, 32 alpha numeric
 @param messageID message ID, 32 alpha numeric
 @return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDeleteRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDelete(ctx context.Context, accountID string, voicemailID string, messageID string) ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDeleteRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDeleteRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
		messageID: messageID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailMessageGetSingle
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDeleteExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDeleteRequest) (*ServiceDocsVoicemailMessageGetSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailMessageGetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}/message/{messageID}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageID"+"}", url.PathEscape(parameterValueToString(r.messageID, "messageID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGetRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
	messageID string
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGetRequest) Execute() (*ServiceDocsVoicemailMessageGetSingle, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGetExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGet Get Voicemail Message Details

Retrieve the container details of an individual voicemail message. This includes a reference to the audio file, but not the message itself.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alpha numeric
 @param voicemailID Voicemail ID, 32 alpha numeric
 @param messageID Message ID, 39 (yyyymm-<32 id>)
 @return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGetRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGet(ctx context.Context, accountID string, voicemailID string, messageID string) ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGetRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGetRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
		messageID: messageID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailMessageGetSingle
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGetExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGetRequest) (*ServiceDocsVoicemailMessageGetSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailMessageGetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}/message/{messageID}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageID"+"}", url.PathEscape(parameterValueToString(r.messageID, "messageID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
	messageID string
	reqBody *ServiceVOIPVoicemailMessageChange
}

// payload fields
func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutRequest) ReqBody(reqBody ServiceVOIPVoicemailMessageChange) ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutRequest {
	r.reqBody = &reqBody
	return r
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutRequest) Execute() (*ServiceDocsVoicemailMessageGetSingle, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPut Update Voicemail Message

Copy or move a voicemail message to a different folder in the same voicemail box or move the message to a separate voicemail box.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alpha numeric
 @param voicemailID Voicemail ID, 32 alpha numeric
 @param messageID Message ID, 39 (yyyymm-<32 id>)
 @return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPut(ctx context.Context, accountID string, voicemailID string, messageID string) ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
		messageID: messageID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailMessageGetSingle
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPutRequest) (*ServiceDocsVoicemailMessageGetSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailMessageGetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}/message/{messageID}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageID"+"}", url.PathEscape(parameterValueToString(r.messageID, "messageID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reqBody == nil {
		return localVarReturnValue, nil, reportError("reqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGetRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
	messageID string
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGetRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGetExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGet Get Voicemail Message File

Get the original audio content of a specific voicemail message identified by its unique ID within an account's voicemail box.
URL Param "voicemailID" is a unique 32-character alphanumeric identifier assigned by the system, which refers to a specific voicemail box.
URL Param "messageID" is a unique 32-character alphanumeric identifier assigned by the system, which refers to a specific message within a voicemail box.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, unique 32-character alphanumeric identifier
 @param voicemailID Voicemail Box ID, unique 32-character alphanumeric identifier
 @param messageID Message ID, unique 32-character alphanumeric identifier
 @return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGetRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGet(ctx context.Context, accountID string, voicemailID string, messageID string) ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGetRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGetRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
		messageID: messageID,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGetExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGetRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}/message/{messageID}/raw"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageID"+"}", url.PathEscape(parameterValueToString(r.messageID, "messageID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
	messageID string
	file *os.File
}

// Audio file to upload
func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostRequest) File(file *os.File) ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostRequest {
	r.file = file
	return r
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPost Add Voicemail Message File

Associate an audio recording file with the voicemail to fully complete the message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alphanumeric characters
 @param voicemailID Voicemail ID, 32 alphanumeric characters
 @param messageID Message ID, 32 alphanumeric characters
 @return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPost(ctx context.Context, accountID string, voicemailID string, messageID string) ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
		messageID: messageID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDMessageMessageIDRawPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}/message/{messageID}/raw"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageID"+"}", url.PathEscape(parameterValueToString(r.messageID, "messageID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDMessagePostRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
	message *ServiceVOIPVoicemailMessageAddData
}

// voicemail message payload fields
func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessagePostRequest) Message(message ServiceVOIPVoicemailMessageAddData) ApiV1AccountAccountIDVoicemailVoicemailIDMessagePostRequest {
	r.message = &message
	return r
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDMessagePostRequest) Execute() (*ServiceDocsVoicemailMessageGetSingle, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDMessagePostExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDMessagePost Create Voicemail Message

Create the container information for a recorded voicemail message in a voicemail box.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID account ID, 32 alphanumeric
 @param voicemailID voicemail ID, 32 alphanumeric
 @return ApiV1AccountAccountIDVoicemailVoicemailIDMessagePostRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessagePost(ctx context.Context, accountID string, voicemailID string) ApiV1AccountAccountIDVoicemailVoicemailIDMessagePostRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDMessagePostRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailMessageGetSingle
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDMessagePostExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDMessagePostRequest) (*ServiceDocsVoicemailMessageGetSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailMessageGetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDMessagePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}/message"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.message == nil {
		return localVarReturnValue, nil, reportError("message is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.message
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1AccountAccountIDVoicemailVoicemailIDPutRequest struct {
	ctx context.Context
	ApiService *VoicemailAPIService
	accountID string
	voicemailID string
	reqBody *ServiceVOIPVoicemailAddEditData
}

// payload fields
func (r ApiV1AccountAccountIDVoicemailVoicemailIDPutRequest) ReqBody(reqBody ServiceVOIPVoicemailAddEditData) ApiV1AccountAccountIDVoicemailVoicemailIDPutRequest {
	r.reqBody = &reqBody
	return r
}

func (r ApiV1AccountAccountIDVoicemailVoicemailIDPutRequest) Execute() (*ServiceDocsVoicemailGetSingle, *http.Response, error) {
	return r.ApiService.V1AccountAccountIDVoicemailVoicemailIDPutExecute(r)
}

/*
V1AccountAccountIDVoicemailVoicemailIDPut Update Voicemail Box

Update the settings in an individual voicemail box, such as the owner, PIN, etc.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID Account ID, 32 alpha numeric
 @param voicemailID Voicemail ID, 32 alpha numeric
 @return ApiV1AccountAccountIDVoicemailVoicemailIDPutRequest
*/
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDPut(ctx context.Context, accountID string, voicemailID string) ApiV1AccountAccountIDVoicemailVoicemailIDPutRequest {
	return ApiV1AccountAccountIDVoicemailVoicemailIDPutRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
		voicemailID: voicemailID,
	}
}

// Execute executes the request
//  @return ServiceDocsVoicemailGetSingle
func (a *VoicemailAPIService) V1AccountAccountIDVoicemailVoicemailIDPutExecute(r ApiV1AccountAccountIDVoicemailVoicemailIDPutRequest) (*ServiceDocsVoicemailGetSingle, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceDocsVoicemailGetSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VoicemailAPIService.V1AccountAccountIDVoicemailVoicemailIDPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/account/{accountID}/voicemail/{voicemailID}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountID"+"}", url.PathEscape(parameterValueToString(r.accountID, "accountID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"voicemailID"+"}", url.PathEscape(parameterValueToString(r.voicemailID, "voicemailID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reqBody == nil {
		return localVarReturnValue, nil, reportError("reqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CPAASError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
